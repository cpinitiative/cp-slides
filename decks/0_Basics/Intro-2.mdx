import { jsx } from 'theme-ui'
import { myTheme } from "../../src/components/mdx-deck/customTheme";
import ListSteps from "../../src/components/mdx-deck/ListSteps";
import { CSTheme } from "../../src/components/mdx-deck/custom-codesurfer-theme";
import { CodeSurfer, Step } from "code-surfer";
import CodeSurferColumns from "../../src/components/mdx-deck/CodeSurferColumns";
import Content from "../../src/components/mdx-deck/Content";
import TightParagraphs from "../../src/components/mdx-deck/TightParagraphs";
import "prismjs/components/prism-java";

export const theme = myTheme;

<h1 style={{ letterSpacing: "0px", textAlign: "center" }}>Competitive Programming</h1>

<TightParagraphs>
(Another) introduction to Competitive Programming.
</TightParagraphs>

---

## What is Competitive Programming?

<Content>

- Activity where participants compete to solve algorithmic problems
- Time frame of about 2 - 5 hours
- Competitive programming has many tangible benefits.
  - **Programming Interviews**: Many interviews for large companies require applicants to solve algorithmic problems to demonstrate capability.
  - **College Applications**: There's nothing that boosts your college applications like winning a big award. If you're dedicated enough, you can make it to the USA national competitive programming team's training camp.

</Content>

---

## Curriculum

<Content>

<div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gridGap: "3rem", margin: "2rem auto" }}>

- File / Standard IO
- Time Complexity
- Data Structures
- Simulation
- Rectangle Geometry
- Sorting
- Sets & Maps
- Complete Search


- Recursion
- Ad Hoc
- Greedy
- Graphs
- Binary Search
- Custom Sorting
- Prefix Sums
- Two Pointers

</div>

</Content>

---

## Want to go faster?

- Self study! https://usaco.guide
- (Coming Soon) https://joincpi.org/classes

---

## Today: Supertrees

<Content>

An example of a simple competitive programming problem.

</Content>

---

## Problem Statement

<Content>

Given $n$ towers $(1 \le n \le 10^3)$, create bridges between towers such that there are $p[i][j]$ $(0 \le p[i][j] \le 3)$ different paths from tower $i$ to tower $j$ (assume there's always a solution).

</Content>

---

## Basic Graph Terminology

- Nodes = towers
- Edges = bridges
- Paths

---

## Sample Case

https://repl.it/@NathanWang/IOI-Supertrees-Tester#main.cpp

---

## Sample Case

<!-- the bars are there to make sure everything is aligned properly -->

$n = 4$

$$
\begin{bmatrix}
1 & 1 & 2 & 2\\
1 & 1 & 2 & 2\\
2 & 2 & 1 & 2\\
2 & 2 & 2 & 1
\end{bmatrix}
$$

---

<Split>
<div> 

Type this:

```
4
0 1
1 2
2 3
1 3
```

</div>

<div>
<img src={img} />
</div>
</Split>

---

## Subtask 1

$$
p[i][j] = 1
$$

$$
\begin{bmatrix}
1 & 1 & 1 & 1\\
1 & 1 & 1 & 1\\
1 & 1 & 1 & 1\\
1 & 1 & 1 & 1
\end{bmatrix}
$$

---

## Subtask 1 Solution

import img6 from "./supertrees_diag6.png"

<img src={img6} />

<Appear>

Connect tower $0$ to all the other towers!

</Appear>

---

## Subtask 2a

$$
p[i][j] = 0 \texttt{ or } 1
$$

(Assume there's always a solution.)

$ n = 4 $

$$
\begin{bmatrix}
1 & 1 & 0 & 0\\
1 & 1 & 0 & 0\\
0 & 0 & 1 & 1\\
0 & 0 & 1 & 1
\end{bmatrix}
$$
---

## Subtask 2a Solution

import img2 from "./supertrees_diag2.png";

<img src={img2} />

---

## Subtask 2b

$ n = 5 $

$$
\begin{bmatrix}
1 & 1 & 0 & 0 & 1\\
1 & 1 & 0 & 0 & 1\\
0 & 0 & 1 & 1 & 0\\
0 & 0 & 1 & 1 & 0\\
1 & 1 & 0 & 0 & 1
\end{bmatrix}
$$

---

## Subtask 2b Solution

import img5 from "./supertrees_diag5.png"

<img src={img5} />

<div style={{ marginBottom: "2em" }}>
<Content>

<Appear>

For each "group" of connected towers, pick one tower. Add a bridge from that tower to every other tower in the group.

</Appear>

</Content>
</div>

---

## Subtask 3

$$
p[i][j] = 0 \texttt{ or } 2
$$

(also 1 for a node and itself)

$$
\begin{bmatrix}
1 & 2 & 0 & 0 & 2 & 0\\
2 & 1 & 0 & 0 & 2 & 0\\
0 & 0 & 1 & 2 & 0 & 2\\
0 & 0 & 2 & 1 & 0 & 2\\
2 & 2 & 0 & 0 & 1 & 0\\
0 & 0 & 2 & 2 & 0 & 1
\end{bmatrix}
$$

---

## Subtask 3 Solution

import img3 from "./supertrees_diag3.png";

<img src={img3} />

<div style={{ marginBottom: "2em" }}>

<Content>

<Appear>

For each connected group, add bridges to make a circle of towers.

</Appear>

</Content>

</div>

---

## Subtask 4a

$$
p[i][j] = 0 \texttt{ or } 1 \texttt{ or } 2
$$

(Assume there's always a solution.)

$$
\begin{bmatrix}
1 & 2 & 0 & 0 & 2 & 0\\
2 & 1 & 0 & 0 & 2 & 0\\
0 & 0 & 1 & 1 & 0 & 1\\
0 & 0 & 1 & 1 & 0 & 1\\
2 & 2 & 0 & 0 & 1 & 0\\
0 & 0 & 1 & 1 & 0 & 1
\end{bmatrix}
$$

---

## Subtask 4a Solution

import img4 from "./supertrees_diag4.png";

<img src={img4} />

---

## Subtask 4b

$$
\begin{bmatrix}
1 & 1 & 1 & 2 & 2 & 2\\
1 & 1 & 1 & 2 & 2 & 2\\
1 & 1 & 1 & 2 & 2 & 2\\
2 & 2 & 2 & 1 & 2 & 2\\
2 & 2 & 2 & 2 & 1 & 2\\
2 & 2 & 2 & 2 & 2 & 1
\end{bmatrix}
$$

---

## Subtask 4b solution

import img7 from "./supertrees_diag7.png"

<img src={img7} />

<Content>

<div style={{ marginBottom: "2em" }}>

<Appear>

- For each "group" of connected towers, pick a random tower $i$.
- For all towers $j$ connected to it by $1$ path, add a single bridge from $i \rightarrow j$.
- Form a cycle with the towers connected to $i$ by $2$ paths.

</Appear>

</div>

</Content>

---
